{"version":3,"sources":["../../src/types/index.ts","../../src/validators/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * TECHNOLOGY TYPE DEFINITIONS\n */\n\nexport type TechnologyType =\n  | 'Language'\n  | 'Framework'\n  | 'Library'\n  | 'Database'\n  | 'Server'\n  | 'Tool'\n  | 'Platform'\n  | 'Stack';\n\n/**\n * COMPONENT INTERFACE\n * Represents a component within a technology stack\n */\nexport interface StackComponent {\n  nombre: string;\n  tipo: Exclude<TechnologyType, 'Stack'>;\n}\n\n/**\n * BASE TECHNOLOGY INTERFACE\n * Common properties for all technology entries\n */\nexport interface BaseTechnology {\n  nombre: string;\n  tipo: TechnologyType;\n}\n\n/**\n * SIMPLE TECHNOLOGY INTERFACE\n * Standard technology without components\n */\nexport interface SimpleTechnology extends BaseTechnology {\n  tipo: Exclude<TechnologyType, 'Stack'>;\n}\n\n/**\n * STACK TECHNOLOGY INTERFACE\n * Technology stack with components\n */\nexport interface StackTechnology extends BaseTechnology {\n  tipo: 'Stack';\n  componentes: StackComponent[];\n}\n\n/**\n * TECHNOLOGY UNION TYPE\n * All possible technology types\n */\nexport type Technology = SimpleTechnology | StackTechnology;\n\n/**\n * CATEGORY METADATA INTERFACE\n */\nexport interface CategoryMetadata {\n  descripcion: string;\n  ejemplos: string[];\n  estructura?: {\n    nombre: string;\n    tipo: string;\n    componentes: Array<{\n      nombre: string;\n      tipo: string;\n    }>;\n  };\n}\n\n/**\n * CATALOG METADATA INTERFACE\n */\nexport interface CatalogMetadata {\n  nombre: string;\n  version: string;\n  descripcion: string;\n  total_tecnologias: number;\n  categorias: Record<string, CategoryMetadata>;\n  uso: string;\n}\n\n/**\n * CATALOG INTERFACE\n * Complete catalog structure\n */\nexport interface Catalog {\n  _metadata: CatalogMetadata;\n  tecnologias: Technology[];\n}\n\n/**\n * SEARCH OPTIONS INTERFACE\n */\nexport interface SearchOptions {\n  fuzzy?: boolean;\n  caseSensitive?: boolean;\n  maxResults?: number;\n  categories?: TechnologyType[];\n}\n\n/**\n * FILTER OPTIONS INTERFACE\n */\nexport interface FilterOptions {\n  type?: TechnologyType | TechnologyType[];\n  includeStacks?: boolean;\n  limit?: number;\n  offset?: number;\n}\n\n/**\n * SEARCH RESULT INTERFACE\n */\nexport interface SearchResult {\n  technology: Technology;\n  score?: number;\n  matches?: {\n    field: 'nombre' | 'tipo';\n    value: string;\n  }[];\n}\n\n/**\n * STATISTICS INTERFACE\n */\nexport interface CatalogStatistics {\n  total: number;\n  byCategory: Record<TechnologyType, number>;\n  totalStacks: number;\n  totalSimpleTechnologies: number;\n  version: string;\n}\n\n/**\n * TYPE GUARDS\n */\nexport function isStackTechnology(tech: Technology): tech is StackTechnology {\n  return tech.tipo === 'Stack';\n}\n\nexport function isSimpleTechnology(tech: Technology): tech is SimpleTechnology {\n  return tech.tipo !== 'Stack';\n}\n\n","/**\n * VALIDATORS MODULE\n * Validation utilities for technology data\n */\n\nimport type { Technology, TechnologyType, StackTechnology } from '../types';\nimport { isStackTechnology } from '../types';\n\n/**\n * VALIDATE TECHNOLOGY OBJECT\n * Checks if an object is a valid Technology\n */\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nexport function validateTechnology(tech: unknown): ValidationResult {\n  const errors: string[] = [];\n\n  if (!tech || typeof tech !== 'object') {\n    return {\n      isValid: false,\n      errors: ['Technology must be an object'],\n    };\n  }\n\n  const techObj = tech as Record<string, unknown>;\n\n  if (!techObj.nombre || typeof techObj.nombre !== 'string') {\n    errors.push('Technology must have a valid \"nombre\" string property');\n  }\n\n  if (!techObj.tipo || typeof techObj.tipo !== 'string') {\n    errors.push('Technology must have a valid \"tipo\" string property');\n  }\n\n  const validTypes: TechnologyType[] = [\n    'Language',\n    'Framework',\n    'Library',\n    'Database',\n    'Server',\n    'Tool',\n    'Platform',\n    'Stack',\n  ];\n\n  if (techObj.tipo && !validTypes.includes(techObj.tipo as TechnologyType)) {\n    errors.push(\n      `Invalid technology type: \"${techObj.tipo}\". Must be one of: ${validTypes.join(', ')}`\n    );\n  }\n\n  if (techObj.tipo === 'Stack') {\n    if (!Array.isArray(techObj.componentes)) {\n      errors.push('Stack technology must have a \"componentes\" array');\n    } else if (techObj.componentes.length === 0) {\n      errors.push('Stack technology must have at least one component');\n    } else {\n      techObj.componentes.forEach((comp: unknown, index: number) => {\n        if (!comp || typeof comp !== 'object') {\n          errors.push(`Component at index ${index} must be an object`);\n          return;\n        }\n\n        const compObj = comp as Record<string, unknown>;\n\n        if (!compObj.nombre || typeof compObj.nombre !== 'string') {\n          errors.push(\n            `Component at index ${index} must have a valid \"nombre\" string`\n          );\n        }\n\n        if (!compObj.tipo || typeof compObj.tipo !== 'string') {\n          errors.push(\n            `Component at index ${index} must have a valid \"tipo\" string`\n          );\n        }\n\n        if (compObj.tipo === 'Stack') {\n          errors.push(`Component at index ${index} cannot be of type \"Stack\"`);\n        }\n      });\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * VALIDATE TECHNOLOGY TYPE\n * Checks if a string is a valid TechnologyType\n */\nexport function isValidTechnologyType(type: string): type is TechnologyType {\n  const validTypes: TechnologyType[] = [\n    'Language',\n    'Framework',\n    'Library',\n    'Database',\n    'Server',\n    'Tool',\n    'Platform',\n    'Stack',\n  ];\n  return validTypes.includes(type as TechnologyType);\n}\n\n/**\n * VALIDATE STACK STRUCTURE\n * Validates that a stack has proper structure\n */\nexport function validateStack(tech: Technology): ValidationResult {\n  const errors: string[] = [];\n\n  if (!isStackTechnology(tech)) {\n    return {\n      isValid: false,\n      errors: ['Technology is not a stack'],\n    };\n  }\n\n  if (!tech.componentes || tech.componentes.length === 0) {\n    errors.push('Stack must have at least one component');\n  }\n\n  const componentNames = new Set<string>();\n  tech.componentes.forEach((comp, index) => {\n    if (componentNames.has(comp.nombre.toLowerCase())) {\n      errors.push(`Duplicate component at index ${index}: \"${comp.nombre}\"`);\n    }\n    componentNames.add(comp.nombre.toLowerCase());\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * VALIDATE CATALOG CONSISTENCY\n * Checks for inconsistencies in the catalog\n */\nexport interface CatalogValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport function validateCatalog(\n  technologies: Technology[]\n): CatalogValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  const names = new Map<string, number>();\n  technologies.forEach((tech, index) => {\n    const normalizedName = tech.nombre.toLowerCase();\n    if (names.has(normalizedName)) {\n      errors.push(\n        `Duplicate technology name \"${tech.nombre}\" at indices ${names.get(normalizedName)} and ${index}`\n      );\n    }\n    names.set(normalizedName, index);\n\n    const validation = validateTechnology(tech);\n    if (!validation.isValid) {\n      errors.push(\n        `Technology at index ${index} (${tech.nombre}) is invalid: ${validation.errors.join(', ')}`\n      );\n    }\n  });\n\n  const stackTechs = technologies.filter((tech) =>\n    isStackTechnology(tech)\n  ) as StackTechnology[];\n\n  stackTechs.forEach((stack) => {\n    stack.componentes.forEach((comp) => {\n      const found = technologies.find(\n        (tech) => tech.nombre.toLowerCase() === comp.nombre.toLowerCase()\n      );\n\n      if (!found) {\n        warnings.push(\n          `Stack \"${stack.nombre}\" references component \"${comp.nombre}\" which is not in the catalog`\n        );\n      } else if (found.tipo !== comp.tipo) {\n        warnings.push(\n          `Stack \"${stack.nombre}\" component \"${comp.nombre}\" has type mismatch: stack says \"${comp.tipo}\", catalog says \"${found.tipo}\"`\n        );\n      }\n    });\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * SANITIZE TECHNOLOGY NAME\n * Cleans and normalizes a technology name\n */\nexport function sanitizeName(name: string): string {\n  return name.trim().replace(/\\s+/g, ' ');\n}\n\n/**\n * VALIDATE SEARCH OPTIONS\n * Validates search options object\n */\nexport function validateSearchOptions(options: unknown): ValidationResult {\n  const errors: string[] = [];\n\n  if (options && typeof options !== 'object') {\n    return {\n      isValid: false,\n      errors: ['Options must be an object'],\n    };\n  }\n\n  const opts = options as Record<string, unknown>;\n\n  if (opts.fuzzy !== undefined && typeof opts.fuzzy !== 'boolean') {\n    errors.push('Option \"fuzzy\" must be a boolean');\n  }\n\n  if (\n    opts.caseSensitive !== undefined &&\n    typeof opts.caseSensitive !== 'boolean'\n  ) {\n    errors.push('Option \"caseSensitive\" must be a boolean');\n  }\n\n  if (opts.maxResults !== undefined) {\n    if (typeof opts.maxResults !== 'number') {\n      errors.push('Option \"maxResults\" must be a number');\n    } else if (opts.maxResults < 1) {\n      errors.push('Option \"maxResults\" must be at least 1');\n    }\n  }\n\n  if (opts.categories !== undefined) {\n    if (!Array.isArray(opts.categories)) {\n      errors.push('Option \"categories\" must be an array');\n    } else {\n      opts.categories.forEach((cat: unknown, index: number) => {\n        if (typeof cat !== 'string' || !isValidTechnologyType(cat)) {\n          errors.push(\n            `Invalid category at index ${index}: must be a valid TechnologyType`\n          );\n        }\n      });\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n"]}